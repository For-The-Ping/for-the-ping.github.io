<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>ForThePing — Word Runner (Chasse)</title>

  <style>
    :root{
      --bg:#0b0f19;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --border:rgba(255,255,255,.10);
      --shadow:0 10px 30px rgba(0,0,0,.45);
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;

      /* Gameplay colors */
      --goodFill: rgba(59,130,246,.18);
      --goodStroke: rgba(59,130,246,.58);
      --goodText: rgba(191,219,254,.98);

      --badFill: rgba(239,68,68,.16);
      --badStroke: rgba(239,68,68,.62);
      --badText: rgba(254,202,202,.98);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: var(--sans);
      overflow-x:hidden;
    }

    /* prevent “bounce scroll” issues on mobile */
    html, body { overscroll-behavior: none; }

    header{
      width:min(980px,100%);
      margin:0 auto;
      padding:16px 16px 10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    header h1{
      margin:0;
      font-size:18px;
      font-weight:900;
      letter-spacing:.2px;
    }
    header h1 span{
      opacity:.75;
      font-weight:800;
    }

    .topBtns{display:flex; gap:10px; align-items:center}
    .btn{
      padding:8px 14px;
      border-radius:12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.08);
      color: var(--text);
      font-weight:900;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      touch-action: manipulation;
    }
    .btn:hover{transform:translateY(-1px); background:rgba(255,255,255,.12); border-color:rgba(255,255,255,.18)}
    .btn:active{transform:translateY(0)}

    .main{
      width:min(980px,100%);
      margin:0 auto;
      padding: 6px 16px 84px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.06);
      box-shadow: var(--shadow);
      touch-action:none; /* critical for mobile */
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 820px){
      .grid2{grid-template-columns:1fr}
    }

    .card{
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px;
      padding:12px;
    }
    .card .title{
      font-weight:900;
      margin-bottom:8px;
    }
    .card p{
      margin:0;
      color: var(--muted);
      line-height:1.5;
      font-size:14px;
    }

    .lb{
      list-style:none;
      padding:0;
      margin:0;
      display:grid;
      gap:6px;
      font-size:14px;
    }
    .lb li{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
    }
    .lb .meta{
      color: var(--muted);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      font-size:13px;
    }
    .lb .score{
      font-weight:900;
      font-family: var(--mono);
    }

    footer{
      padding:18px 16px 26px;
      color: var(--muted);
      font-size:12px;
      text-align:center;
    }

    /* ============ TOUCH UI (joystick) ============ */
    #touchUI{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      padding: 14px 14px 18px;
      display: none; /* shown on mobile only */
      pointer-events: none;
      z-index: 20;
    }
    #touchRow{
      display:flex;
      align-items:center;
      gap: 12px;
      max-width: 980px;
      margin: 0 auto;
    }
    #joyBase{
      width: 140px; height: 140px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.05);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      position: relative;
      pointer-events: auto;
      touch-action: none;
    }
    #joyKnob{
      width: 54px; height: 54px;
      border-radius: 999px;
      background: rgba(255,255,255,.18);
      border: 1px solid rgba(255,255,255,.22);
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%,-50%);
    }
    #touchHint{
      color: rgba(255,255,255,.65);
      font-size: 12px;
      line-height: 1.25;
      user-select:none;
    }

    @media (max-width: 820px){
      #touchUI{ display:block; }
    }
  </style>
</head>

<body>
  <header>
    <h1>ForThePing <span>— Word Runner (Chasse)</span></h1>
    <div class="topBtns">
      <button class="btn" id="btnStart">Démarrer</button>
      <button class="btn" id="btnReset">Reset</button>
    </div>
  </header>

  <div class="main">
    <canvas id="cv" width="960" height="540"></canvas>

    <div class="grid2">
      <div class="card">
        <div class="title">Contrôles</div>
        <p>
          PC : ZQSD / WASD / flèches.<br/>
          Mobile : joystick (pouce gauche).<br/>
          Mange les <b style="color:rgba(191,219,254,.98)">mots bleus</b> (+score, +niveau). Évite les
          <b style="color:rgba(254,202,202,.98)">mots rouges</b> (−1 vie). 3 vies.
        </p>
      </div>

      <div class="card">
        <div class="title">Classement (local)</div>
        <ul class="lb" id="lb"></ul>
        <p id="lbEmpty" style="display:none; color:var(--muted); margin:0">Aucun score pour l’instant.</p>
      </div>
    </div>
  </div>

  <footer>Aucune donnée ne sort de ton navigateur. (localStorage)</footer>

  <!-- Touch controls -->
  <div id="touchUI">
    <div id="touchRow">
      <div id="joyBase"><div id="joyKnob"></div></div>
      <div id="touchHint">
        Pouce gauche = déplacer<br>
        (PC: flèches / WASD)
      </div>
    </div>
  </div>

<script>
"use strict";

/* =========================
   CONFIG
========================= */
const W = 960, H = 540;

// Player
const PLAYER_R = 12;
const PLAYER_SPEED = 2.35;

// Lives / invuln
const MAX_LIVES = 3;
const INVULN_SEC = 1.2;

// Words sizing
const WORD_H = 26;
const WORD_PAD = 10;

// Spawn safety
const SAFE_SPAWN_MARGIN = 140;
const MAX_OVERLAP_TRIES = 180;

// Level rules
const LEVEL_UP_EVERY_GOODS = 4;

// Counts per level
function goodCountForLevel(lv){ return clamp(3 + Math.floor(lv/2), 3, 6); }
function enemyCountForLevel(lv){ return clamp(2 + lv, 2, 10); }

// Enemy speed
function enemySpeedMin(lv){ return 55 + lv*18; }
function enemySpeedMax(lv){ return 95 + lv*24; }

// Steering
function enemyJitter(lv){ return clamp(22 + lv*3, 22, 44); }
const HOMING_SMOOTH = 6.5;

// Anti-grouping
const SEP_RADIUS = 160;
const SEP_FORCE = 520;
const WANDER_FORCE = 110;
const WANDER_FREQ = 0.9;

// Redirect on game over
const REDIRECT_URL = "https://fortheping.com/";
const REDIRECT_DELAY_MS = 1200;

/* =========================
   LEXICON (fixed)
========================= */
const GOOD_WORDS = [
  "Architecture","Infrastructure","Structure","Système","Réseau","Télécommunication",
  "Interconnexion","Segmentation","Redondance","Résilience",
  "Performance","Stabilité","Continuité","Disponibilité","Flux",
  "Optimisation","Amélioration","Efficacité","Fluidité","Simplification","Rationalisation","Gain",
  "Gouvernance","Gestion","Documentation","Formation","Vision","Décision","Priorités","Alignement","Cohérence",
  "Clarté","Expérience","Fiabilité","Solidité","Résultats concrets","Ce qui fonctionne","Ce qui compte",
  "IA","Intelligence artificielle","Cloud","Innovation"
];
const BAD_WORDS = [
  "Flou","Jargon inutile","Complexité inutile","Bruit","Surcouche",
  "Rapports embellis","Parler pour ne rien dire","Vendre du rêve"
];
const BUZZ = new Set(["IA","Cloud","Innovation","Intelligence artificielle"]);

/* =========================
   HELPERS
========================= */
function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
function rand(a,b){ return a + Math.random()*(b-a); }
function pick(arr){ return arr[(Math.random()*arr.length)|0]; }
function rectsOverlap(a,b){
  return !(
    a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h
  );
}
function circleRectCollision(c, r){
  const cx = clamp(c.x, r.x, r.x + r.w);
  const cy = clamp(c.y, r.y, r.y + r.h);
  const dx = c.x - cx, dy = c.y - cy;
  return dx*dx + dy*dy <= c.r*c.r;
}
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }

/* =========================
   LEADERBOARD
========================= */
const LB_KEY = "ftp_word_runner_lb_v3";
function loadScores(){
  try { return JSON.parse(localStorage.getItem(LB_KEY) || "[]"); }
  catch { return []; }
}
function saveScore({score, level}){
  const rec = { score, level, date: new Date().toLocaleString() };
  const arr = loadScores();
  arr.push(rec);
  arr.sort((a,b)=> (b.score - a.score) || (b.level - a.level));
  const top = arr.slice(0, 8);
  localStorage.setItem(LB_KEY, JSON.stringify(top));
  return top;
}
function renderLB(){
  const el = document.getElementById("lb");
  const empty = document.getElementById("lbEmpty");
  const lb = loadScores();
  el.innerHTML = "";
  if(lb.length === 0){ empty.style.display = "block"; return; }
  empty.style.display = "none";
  lb.forEach((r,i)=>{
    const li = document.createElement("li");
    const meta = document.createElement("div");
    meta.className = "meta";
    meta.textContent = `${i+1}. ${r.date} — Niv ${r.level}`;
    const sc = document.createElement("div");
    sc.className = "score";
    sc.textContent = r.score;
    li.appendChild(meta);
    li.appendChild(sc);
    el.appendChild(li);
  });
}

/* =========================
   CANVAS / INPUT
========================= */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");

const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

/* =========================
   TOUCH JOYSTICK
========================= */
let touchVec = { x: 0, y: 0 }; // -1..1
let joyActive = false;
let joyCenter = { x: 0, y: 0 };
const JOY_RADIUS = 55;

const joyBase = document.getElementById("joyBase");
const joyKnob = document.getElementById("joyKnob");
const isTouch = matchMedia("(pointer: coarse)").matches || "ontouchstart" in window;

function setKnob(dx, dy){
  if(!joyKnob) return;
  joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}
function updateTouchVec(clientX, clientY){
  const dx = clientX - joyCenter.x;
  const dy = clientY - joyCenter.y;
  const d = Math.hypot(dx, dy) || 1;
  const clamped = Math.min(JOY_RADIUS, d);
  const nx = (dx / d) * (clamped / JOY_RADIUS);
  const ny = (dy / d) * (clamped / JOY_RADIUS);
  touchVec.x = nx;
  touchVec.y = ny;
  setKnob(nx * JOY_RADIUS, ny * JOY_RADIUS);
}

if(isTouch && joyBase){
  const computeCenter = () => {
    const r = joyBase.getBoundingClientRect();
    joyCenter.x = r.left + r.width / 2;
    joyCenter.y = r.top + r.height / 2;
  };
  computeCenter();
  window.addEventListener("resize", computeCenter);

  joyBase.addEventListener("pointerdown", (e) => {
    joyActive = true;
    computeCenter();
    joyBase.setPointerCapture(e.pointerId);
    updateTouchVec(e.clientX, e.clientY);
  });

  joyBase.addEventListener("pointermove", (e) => {
    if(!joyActive) return;
    updateTouchVec(e.clientX, e.clientY);
  });

  const release = () => {
    joyActive = false;
    touchVec.x = 0;
    touchVec.y = 0;
    setKnob(0,0);
  };
  joyBase.addEventListener("pointerup", release);
  joyBase.addEventListener("pointercancel", release);

  // prevent page scroll while using joystick
  joyBase.style.touchAction = "none";
}

/* =========================
   GAME STATE
========================= */
const game = {
  running:false,
  over:false,
  score:0,
  level:1,
  lives:MAX_LIVES,
  goodsEaten:0,
  time:0,
  msg:"",
  invuln:0,

  player:{ x: W/2, y: H/2, r: PLAYER_R },
  goods:[],
  enemies:[],
};

let redirectArmed = false;

/* =========================
   FLOW
========================= */
function reset(){
  redirectArmed = false;

  game.running = false;
  game.over = false;
  game.score = 0;
  game.level = 1;
  game.lives = MAX_LIVES;
  game.goodsEaten = 0;
  game.time = 0;
  game.msg = "";
  game.invuln = 0;

  game.player = { x: W/2, y: H/2, r: PLAYER_R };
  game.goods = [];
  game.enemies = [];

  spawnLevel();
  draw();
}

function start(){
  if(game.over) reset();
  game.running = true;
  game.over = false;
  game.msg = "";
  lastT = performance.now();
  requestAnimationFrame(loop);
}

function gameOver(){
  if(redirectArmed) return;
  redirectArmed = true;

  game.running = false;
  game.over = true;
  game.msg = "Fin — redirection vers fortheping.com…";

  saveScore({ score: game.score, level: game.level });
  renderLB();
  draw();

  setTimeout(() => {
    window.location.assign(REDIRECT_URL);
  }, REDIRECT_DELAY_MS);
}

/* =========================
   SPAWN (SAFE + NO OVERLAP)
========================= */
function playerSafeRect(r){
  const px = game.player.x, py = game.player.y;
  const cx = r.x + r.w/2, cy = r.y + r.h/2;
  return dist(px,py,cx,cy) >= SAFE_SPAWN_MARGIN + game.player.r;
}

function measureWord(label){
  ctx.font = "13px system-ui, -apple-system, Segoe UI, sans-serif";
  const tw = ctx.measureText(label).width;
  const w = Math.min(340, Math.max(90, tw + WORD_PAD*2));
  return { w, h: WORD_H };
}

function placeRect(rect, blockers){
  let tries = 0;
  while(tries++ < MAX_OVERLAP_TRIES){
    rect.x = rand(10, W - rect.w - 10);
    rect.y = rand(10, H - rect.h - 10);
    if(!playerSafeRect(rect)) continue;
    if(blockers.some(b => rectsOverlap(b, rect))) continue;
    return true;
  }
  return false;
}

function spawnGood(blockers){
  const label = pick(GOOD_WORDS);
  const size = measureWord(label);
  const r = { x:0, y:0, w:size.w, h:size.h, label, bad:false };
  if(placeRect(r, blockers)){
    game.goods.push(r);
    blockers.push(r);
  }
}

function spawnEnemy(blockers){
  let label = pick(BAD_WORDS);

  // optional: buzzwords as enemies at low levels
  if(game.level <= 2 && Math.random() < 0.18){
    const bw = pick(Array.from(BUZZ));
    label = bw + " (pas ancré)";
  }

  const size = measureWord(label);
  const r = { x:0, y:0, w:size.w, h:size.h, label, bad:true };
  if(!placeRect(r, blockers)) return;

  const spd = rand(enemySpeedMin(game.level), enemySpeedMax(game.level));
  const ang = rand(0, Math.PI*2);

  game.enemies.push({
    ...r,
    vx: Math.cos(ang) * (spd * 0.15),
    vy: Math.sin(ang) * (spd * 0.15),
    speed: spd,
    jitter: enemyJitter(game.level),

    wx: Math.cos(ang) * WANDER_FORCE,
    wy: Math.sin(ang) * WANDER_FORCE,
    wt: rand(0, WANDER_FREQ),
  });

  blockers.push(r);
}

function spawnLevel(){
  game.goods = [];
  game.enemies = [];

  const blockers = [];

  const gCount = goodCountForLevel(game.level);
  for(let i=0;i<gCount;i++) spawnGood(blockers);

  const eCount = enemyCountForLevel(game.level);
  for(let i=0;i<eCount;i++) spawnEnemy(blockers);

  game.msg = `Niveau ${game.level} — tiens bon.`;
}

/* =========================
   LOOP
========================= */
let lastT = 0;

function loop(t){
  if(!game.running) return;
  const dt = Math.min(0.05, (t - lastT)/1000);
  lastT = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* =========================
   UPDATE
========================= */
function update(dt){
  game.time += dt;
  if(game.invuln > 0) game.invuln = Math.max(0, game.invuln - dt);

  // Movement: keyboard + joystick
  let mx = 0, my = 0;
  const k = keys;

  // keyboard
  if(k["arrowleft"] || k["a"] || k["q"]) mx -= 1;
  if(k["arrowright"] || k["d"]) mx += 1;
  if(k["arrowup"] || k["w"] || k["z"]) my -= 1;
  if(k["arrowdown"] || k["s"]) my += 1;

  // joystick
  mx += touchVec.x;
  my += touchVec.y;

  // normalize so diagonal isn't faster
  const mag = Math.hypot(mx, my);
  if(mag > 1){ mx /= mag; my /= mag; }

  game.player.x = clamp(game.player.x + mx * PLAYER_SPEED, PLAYER_R, W - PLAYER_R);
  game.player.y = clamp(game.player.y + my * PLAYER_SPEED, PLAYER_R, H - PLAYER_R);

  // Enemies chase + separation
  const px = game.player.x, py = game.player.y;

  for(let i=0;i<game.enemies.length;i++){
    const e = game.enemies[i];

    // wander refresh
    e.wt -= dt;
    if(e.wt <= 0){
      e.wt = rand(0.4, WANDER_FREQ);
      const a = rand(0, Math.PI*2);
      e.wx = Math.cos(a) * WANDER_FORCE;
      e.wy = Math.sin(a) * WANDER_FORCE;
    }

    const ex = e.x + e.w/2, ey = e.y + e.h/2;

    // homing direction
    let dx = px - ex, dy = py - ey;
    const d = Math.max(0.001, Math.hypot(dx,dy));
    dx /= d; dy /= d;

    // jitter
    const jx = rand(-1,1) * (e.jitter * 0.001);
    const jy = rand(-1,1) * (e.jitter * 0.001);

    // separation
    let sx = 0, sy = 0;
    for(let j=0;j<game.enemies.length;j++){
      if(i===j) continue;
      const o = game.enemies[j];
      const ox = o.x + o.w/2, oy = o.y + o.h/2;
      const ddx = ex - ox, ddy = ey - oy;
      const dd = Math.hypot(ddx,ddy);
      if(dd > 0 && dd < SEP_RADIUS){
        const push = (SEP_RADIUS - dd) / SEP_RADIUS;
        sx += (ddx / dd) * push;
        sy += (ddy / dd) * push;
      }
    }
    const sm = Math.hypot(sx,sy);
    if(sm > 0.001){ sx/=sm; sy/=sm; }

    // combine
    const targetVx = (dx + jx) * e.speed + sx * SEP_FORCE + e.wx;
    const targetVy = (dy + jy) * e.speed + sy * SEP_FORCE + e.wy;

    // smooth steering
    const blend = clamp(HOMING_SMOOTH * dt, 0, 1);
    e.vx += (targetVx - e.vx) * blend;
    e.vy += (targetVy - e.vy) * blend;

    e.x += e.vx * dt;
    e.y += e.vy * dt;

    // bounds
    if(e.x < 6){ e.x = 6; e.vx *= -0.28; }
    if(e.y < 6){ e.y = 6; e.vy *= -0.28; }
    if(e.x + e.w > W-6){ e.x = W-6 - e.w; e.vx *= -0.28; }
    if(e.y + e.h > H-6){ e.y = H-6 - e.h; e.vy *= -0.28; }
  }

  // Goods collision
  for(let i=game.goods.length-1;i>=0;i--){
    const g = game.goods[i];
    if(circleRectCollision(game.player, g)){
      game.goods.splice(i,1);
      game.score += 150 + game.level*10;
      game.goodsEaten += 1;
      game.msg = `+ ${g.label}`;

      // respawn one good
      const blockers = [
        ...game.goods,
        ...game.enemies.map(en=>({x:en.x,y:en.y,w:en.w,h:en.h}))
      ];
      spawnGood(blockers);

      // level up
      if(game.goodsEaten % LEVEL_UP_EVERY_GOODS === 0){
        game.level += 1;
        game.score += 250;
        spawnLevel();
        game.invuln = Math.max(game.invuln, 0.6);
      }
    }
  }

  // Enemy collision
  if(game.invuln <= 0){
    for(const e of game.enemies){
      if(circleRectCollision(game.player, e)){
        game.lives -= 1;

        if(game.lives <= 0){
          game.msg = `Tu t’es fait avoir par : "${e.label}"`;
          return gameOver();
        }

        game.msg = `Ouch! "${e.label}" — il te reste ${game.lives} vie${game.lives>1?"s":""}.`;
        game.player.x = W/2;
        game.player.y = H/2;
        game.invuln = INVULN_SEC;

        // spawn extra enemy on hit (cap)
        if(game.enemies.length < 14){
          const blockers = [
            ...game.goods,
            ...game.enemies.map(en=>({x:en.x,y:en.y,w:en.w,h:en.h}))
          ];
          spawnEnemy(blockers);
        }
        break;
      }
    }
  }

  // Small survival score
  game.score = Math.max(game.score, Math.floor(game.time * 6));
}

/* =========================
   DRAW
========================= */
function roundRect(x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}
function centerText(a,b){
  ctx.save();
  ctx.globalAlpha = 0.96;
  ctx.textAlign = "center";
  ctx.fillStyle = "rgba(255,255,255,.95)";
  ctx.font = "900 26px system-ui, -apple-system, Segoe UI, sans-serif";
  ctx.fillText(a, W/2, H/2 - 16);
  ctx.globalAlpha = 0.75;
  ctx.font = "13px system-ui, -apple-system, Segoe UI, sans-serif";
  ctx.fillText(b, W/2, H/2 + 12);
  ctx.restore();
}

function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#0b0f19";
  ctx.fillRect(0,0,W,H);

  // HUD
  ctx.fillStyle = "white";
  ctx.font = "14px system-ui, -apple-system, Segoe UI, sans-serif";
  ctx.fillText(`Score: ${game.score}`, 12, 22);
  ctx.fillText(`Niveau: ${game.level}`, 12, 42);
  ctx.fillText(`Vies: ${game.lives}`, 12, 62);

  if(game.invuln > 0){
    ctx.fillStyle = "rgba(255,255,255,.70)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.fillText(`Bouclier: ${(game.invuln).toFixed(1)}s`, 12, 82);
  }
  if(game.msg){
    ctx.fillStyle = "#ffd166";
    ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText(game.msg, 12, 108);
  }

  const goodFill = cssVar("--goodFill");
  const goodStroke = cssVar("--goodStroke");
  const goodText = cssVar("--goodText");

  for(const g of game.goods){
    ctx.fillStyle = goodFill;
    ctx.strokeStyle = goodStroke;
    roundRect(g.x, g.y, g.w, g.h, 10);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = goodText;
    ctx.font = "13px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";
    ctx.fillText(g.label, g.x + WORD_PAD, g.y + g.h/2);
  }

  const badFill = cssVar("--badFill");
  const badStroke = cssVar("--badStroke");
  const badText = cssVar("--badText");

  for(const e of game.enemies){
    ctx.fillStyle = badFill;
    ctx.strokeStyle = badStroke;
    roundRect(e.x, e.y, e.w, e.h, 10);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = badText;
    ctx.font = "13px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";
    ctx.fillText(e.label, e.x + WORD_PAD, e.y + e.h/2);
  }

  // Player
  ctx.save();
  const p = game.player;
  if(game.invuln > 0){
    const blink = (Math.floor(game.time * 12) % 2) === 0;
    ctx.globalAlpha = blink ? 0.45 : 1;
  }
  ctx.beginPath();
  ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
  ctx.fillStyle = "#ff6ad5";
  ctx.fill();
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(255,255,255,.25)";
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();

  if(!game.running && !game.over){
    centerText("WORD RUNNER", "Démarre. Les mots rouges te chassent.");
  }
  if(game.over){
    centerText("FIN", "Redirection vers fortheping.com…");
  }
}

/* =========================
   UI hooks
========================= */
document.getElementById("btnStart").addEventListener("click", ()=>{
  if(!game.running) start();
});
document.getElementById("btnReset").addEventListener("click", ()=>{
  reset();
});

/* =========================
   Init
========================= */
reset();
renderLB();
</script>
</body>
</html>
